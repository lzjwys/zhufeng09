<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    number(数字)  string(字符串) boolean(布尔) null undefined

    Boolean() //把其他数据类型强制转化为布尔数据类型
    false: 0 NaN  "" null undefined 其他自身做布尔运算都是true
    1 两个对象数据类型比较永远不相等(除了是同一个空间引用地址)
    2 对象 == 字符串  对象转化成字符串
    3 null == undefined
    4 null和undefiend和其他数据类型做比较都是不相等的
    5 任何数据类型之间做比较如有等号两边有数字的强制转化为数字，两边没有数字的也都强制转化为数字，一个引用数据类型转化为数字需要先转化成字符串然后再转化成数字
    undefined:  1 var obj = {}  obj.xxx = undefiend
                对象不存在的属性
                2 函数参数
                函数没有传的形参
                3 return undefined
                函数没写返回值
    null: 空  通过id获取元素没有id

    引用: {}  []  /\d\w/ newDate() function .... 通过dom方法获取回来的dom对象都是引用数据类型的

    typeof 'number' 'string' 'boolean' 'object' 'undefined' 'function'

</body>
</html>
<script>
    /*
    *   数组: [1,2,3,{},[]]
    *       length: 数组的长度，数组里有多少个项
    *       数组是一个特殊的对象: 数组的属性名字都是数字，并且是从0开始依次增加
    *       索引(index): 索引是从0开始，最后一个索引(length-1)
    *       可以通过索引给数组项目重新赋值
    *       ary[ary.length] = value  向数组的末尾添加一项
    *       ary.length-- 可以删除最后一项
    *       可以通过length属性和for循环遍历数组的每一项
    *       也可以通过for in遍历数组
    * */
    var ary = [1,2,3];
    //ary[ary.length-1]    ary[0]
    ary[ary.length-1] = '3';
    ary[ary.length] = '6'; //向数组的末尾添加一项
    console.log(ary); //在js中Array就代表数组这一类
    ary.length--; //在自身的基础上-1
    console.log(ary);
    //ary.length++;
    for(var i=0; i<ary.length; i++){ //i<3
        console.log(ary[i]); // ary[0]  ary[1] ary[2]
    }
    console.log(i);
    //
    var ary = ['x','y','z'];  //0:x  1:y 2:z
    var i=0;
    /*while(i<ary.length){ //只要i<3我这个循环就会执行下去
        console.log(ary[i]);
        i++; //
    }*/
    var ary = []; //[1,2,3]
    //debugger; //代码运行到这里就停止了，如果想继续需要我们主动去按照每一行执行。F11就是逐行执行,如果不想执行了直接F8跳出,如果想监控变量选中右键add to watch就可以在右侧的watch菜单内实时监控
    while(ary.length<3){
        ary[ary.length] = ary.length+1;
        //ary[0] = 1;
        //ary[1] = 2;
        //ary[2] = 3;
        //ary的length在这会就已经是3
    }
/*
    for(var key in ary){ //
        console.log(key); //0,1,2
        console.log(ary[key]);
    }
*/

    /*
    *   js中常用的数组方法 ：
    *       1  方法的作用
    *       2  参数
    *       3  返回值(方法运行完之后留下了什么)
    *       4  是否改变原有数组
    * */
    var ary = ['x','y','z'];
    //增加 删除  修改  查询(复制)
    /*
    *  push  1 向数组的末尾增加项,如果是多项用","隔开  ary[ary.length] = "$";
    *        2 要增加的数组项
    *        3 数组的新长度
    *        4 原有数组改变
    *
    * */
    var res = ary.push("$","￥");
    console.log(ary);
    console.log(res);
    /*
    *  unshift 1 向数字的开头增加项,如果是多个用","隔开
    *          2 要增加的数组项
    *          3 数组的新长度
    *          4 原有数组改变
    * */
    var ary = ['x','y'];
    var res = ary.unshift('$',"&");
    console.log(ary);
    console.log(res);

    /*
    *  pop   1 删除数组的最后一项
    *        2 不用参数
    *        3 返回值是删除的最后一项
    *        4 原有数组改变
    *
    * */

    var ary = [1,2];
    var res = ary.pop();
    console.log(ary);
    console.log(res);

    /*
    *  shift 1 删除数组的第一项
    *        2 也不用参数
    *        3 返回删除的第一项
    *        4 原有数组改变
    *
    * */

    var ary = ["y"];
    var res = ary.shift();
    console.log(res);
    console.log(ary);

    /*
    *   splice  1 删除数组项
    *           2 splice(n)  从索引n开始删除到末尾
    *             splice(0)  返回就是原有数组的所有项组成的新数组  ==> 可以达到克隆数组的目的
    *             splice(n,m)  从索引n开始删除m个
    *             splice(n,m,x)  从索引n开始删除m个，然后把x放在删除的位置
    *             splice(n,m,x,y...)  从索引n开始删除m个，然后把从第三个参数x开始到最后一个参数都同时插入到删除的索引位置
    *             splice(n,0,x)  就是把x插入到n的"前面"
    *             push ==> splice(ary.length,0,x)
    *             unshift ==> splice(0,0,x)
    *             shift ==> splice(0,1)
    *             pop ==> splice(ary.length-1,1)
    *           3 删除的数组项组成的新数组
    *           4 原有数组改变
    * */
    var ary = [1,2,3,4,'x']; //
    //var res = ary.splice(2,2);
    //var res = ary.splice(2);
    //var res = ary.splice(2,2,'$',"%");
    var res = ary.splice(2,0,'$'); //
    console.log(ary);
    console.log(res);

    /*
    *   slice 1 复制数组
    *         2   slice()  从开头复制到结尾,返回一个新的数组和原有相同  克隆数组
    *             slice(n)  从索引n开始复制到末尾
    *             slice(0)  克隆数组
    *             slice(n,m)  从索引n开始到索引m-1（索引n开始到索引m但是不包含m）
    *         3 返回复制的新数组
    *         4 原有数组不变
    * */

    var ary = [1,2,3,"x","y","z"];
    //var res = ary.slice(2,4);
    //var res = ary.slice();
    var res = ary.slice(3,5);
    console.log(ary);
    console.log(res);
    console.log(ary == res); //false

    //拼接
    /*
    *   concat 1 拼接数组
    *          2 concat() 返回一个和原有数组相同的数组   克隆数组
    *            concat([]) 返回一个和原有数组相同的数组   克隆数组
    *            concat(ary1,ary2,3)  拼接数组参数可以是数组，也可以是单独的数组项，也可以是多个
    *          3 拼接好的新数组
    *          4 原有数组不变
    *
    *   join  1 把数组中的每一项按照指定的分隔符拼接成字符串
    *         2 参数就是指定的分隔符
    *         3 返回拼接好的字符串
    *         4 原有数组不变
    *       eval ==> 可以把字符串当作js表达式去运行(去引号),可以利用eval求和
    *
    * */
    var ary1 = [1];
    var ary2 = [2];
    var ary3 = ['3'];
    //var res = ary1.concat(ary2).concat(ary3).slice(0).splice(0).push('a');
    var res = ary1.concat();
    console.log(res == ary1);

    //join
    //var ary = ["x","y","z"];
    var ary = [1,2,3]; //sum  arguments[].join(++++)
    var res = ary.join("+"); //"1+2+3"
    console.log(eval(res)); //6
    //eval ==> 可以把字符串当作js表达式去运行(去引号)
    //var res = ary.join("$"); //"x$y$z"
    //var res = ary.join(""); //"x$y$z"
    //var res = ary.join(); //"x$y$z"

    //排序
    /*
    *   reverse  1 倒序数组
    *            2 不用参数
    *            3  倒序过后的原有数组
    *            4  原有数组改变(顺序改变)
    *
    * */
    var ary = [1,2,3];
    var res = ary.reverse();
    console.log(res);
    console.log(ary);
    console.log(res ==  ary);

    /*
    *   sort   1 可以按照指定规则排序数组(升序，或者降序)
    *          2  匿名函数(指定规则)
    *               sort(function (x,y){ return x-y })  升序
    *               sort(function (a,b){ return b-a })  降序
    *          3 已经排序好的原有数组
     *         4  原有数组改变(顺序)
    *
    * */
    console.log('&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&');
    var ary = [3,10,2,5,4];
    var res = ary.sort(function (a,b){
        console.log(a,b); //a,b其实相邻的数组项  3,10
        return a-b; //return的这个值就是是否改变位置的关键
    });
    console.log(res);
    console.log(ary);
    console.log(res === ary);

/*
    function fn(param){
        if(typeof param ==  'function'){
            for(var i=0; i<50; i++){}
            param();
        }
    }
*/


    //兼容性不好的4个
    /*
    *   indexOf  1 查看数组项在数组中的索引位置
    *            2 要查看的项
    *            3 如果这个项出现在数组中那么返回对应的索引，如果没有出现返回-1
    *            4 原有数组不变
    *
    *   lastIndexOf  1  查看数组项在数组中的最后一次出现的索引位置
    *                2 要查看的项
    *                3 如果这个项出现在数组中那么返回对应最后出现的索引，如果没有出现返回-1
    *                4 原有数组不变
    * */
    var ary = [22,'1',2,3,'x',22,22];
    var res = ary.indexOf(22);
    console.log(res);
    console.log(ary);

    /*
    *   forEach    1 循环遍历数组的每一项
    *              2 需要一个匿名函数参数
    *              3 undefined
    *              4 原有数组不变
    * */
    var ary = ['x','y','z'];
    var res = ary.forEach(function(item,index,oriAry){
        console.log(item);
    });
    console.log(res);
    console.log(ary);

    /*
    *   map  1 循环遍历数组
    *        2 需要一个函数
    *        3 匿名函数return的值组成一个新的数组
    *        4 原有数组不变
    * */
    var ary = [1,2,'x','y'];
    var res = ary.map(function (item,index,oriAry){
        //return item+index;
        //return oriAry[index];
        return {item: item,index: index}
    });
    console.log(res);













</script>