<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <div id="div1" style="width: 100px; height: 100px; background: red;"></div>
</body>
</html>
<script>
    /*
    *   函数:  function  也要遵循引用数据类型的赋值过程
    *
    *
    * */
    //var sum = function (){}  //函数表达式
    function sum(){ //求和函数
        //用花括号包起来的就叫做函数体
        var a = 5;
        var b = 6;
        console.log(1+2);
    }
    ///sum(); //函数的执行,函数名字+小括号

    //我这个函数只能求1+2的和,==> 我想求任意两个数的和? ==> 如果1和2是两个可以变化的值就可以了,但是这个变量不能在函数体内声明
    //我现在这个函数需要一个可以变的量，并且这个量还是从函数外面进来的==>需要提供函数u入口，这个入口在函数中叫做参数,参数定义在小括号的里面，多个参数用逗号隔开

    function sum(num1,num2){
        //var num1;
        //var num2;
        console.log(num1);
        console.log(num2);


        console.log(num1 + num2);
    }
    //参数分形参和实参：在函数定义的时候放在参数的位置的就是形参，函数执行的时候放在参数的位置才是实参
    //对于形参的理解: 形参虽然没有用var声明过，但是却有和var相同的作用。形参相当于在函数体内声明的变量

    //对于函数的形参如果定义了却在执行的时候没有传实参那么在函数体内就是undefined

    //sum(7);


    function sum(num1,num2){
        var total = 0;
        if(typeof num1 != 'undefined'){

            total += num1; // ;total = total + num1;
        }
        if(typeof num2 != 'undefined'){
            total += num2;
        }
        console.log(total);
    }
    //sum(7,'8'); // '8'  '8px'

    //如果是字符串那么我要对这个字符串做有效性验证
    function sum(num1,num2){
        var total = 0;
        if(typeof num1 != 'undefined'){
            if(!isNaN(num1)){
                total += Number(num1);
            }
        }
        if(typeof num2 != 'undefined'){
            if(!isNaN(num2)){
                total += Number(num2);
            }
        }
        console.log(total);
    }

    //sum(7,'8');

    //可以求任意两个数的和了 ==> 想求多位数的和没有办法定义参数的个数了 ==> arguments

    //arguments: 函数在执行的时候在函数体内会默认有一个arguments的类数组。类数组里面的存的是索引的函数实参集合


    function sum(){
        //console.log(arguments);
        //console.log(arguments.callee === sum); //预解释
        var total = 0;
        for(var i=0; i<arguments.length; i++){
            if(!isNaN(arguments[i])){
                total += Number(arguments[i]);
            }
            //!isNaN(arguments[i]) ? total += Number(arguments[i]): void 0;
        }
        //console.log(total); //仅仅是在控制台打印

        //return total,"我是积" ; //如果函数想在运行之后留下结果必须用return,return后面是什么函数留下什么
        return { total: total, ji: '积'};
        //如果函数没有写return默认返回一个undefined
        alert('ok'); //return下面的代码不执行
    }
    var res = sum(1,2,3,4,'5','6px'); //res是用来接收sum函数的返回值,
    //所有的赋值过程都是先把等号右面计算好之后再赋值给等号左边
    //console.log(res.total);

   /* true && alert();
    var a  = a || b;
    var a = a && b || c;*/

    // arguments.callee在函数体内代表函数本身

    //return可以理解为这是函数的出口,既然可以return都可以retrun一个对象，那么参数也可以传一个对象或者数组甚至是函数


    //对于刚刚那个sum是有名字的函数叫做实名函数，如果没有名字的函数叫做匿名函数，匿名函数不能单独出现只能直接赋值给其他属性或者自运行

    (function fn(){
        //alert(0);
    })();

/*
    !function (){alert(0)}();
    +function (){alert(0)}();
    -function (){alert(0)}();
    ~function (){alert(0)}();
*/

    //fn();


    function sum(){
        return (function (){
            alert(1);
            //这个自运行函数里没有return，默认留下一个undefined
        })(); //那就等着这个自运行函数的运行结果，再return给res
    }
    var res = sum(); //undefined
    res(); // res is not a function















/*
    var div1 = document.getElementById('div1');
    div1.onmouseover = function (){}
*/

/*
    function fn(){
        console.log(1);
    }
*/


   /* var obj = {
        name:'tianxi',
        englishName: obj.name+'allen' //此时的obj还没有堆内存的引用地址
    }
*/
    //引用数据类型的赋值步骤: 1 先开辟一个新的堆内存空间  2 把属性名字和属性值当作字符串存到这个空间中 3 把空间地址赋值给变量
    //ps:  在第3步之前我这个变量的赋值动作还没有结束，我这个变量ojb还没有这个空间地址呢


    //  function  形参，实参，函数的赋值过程，arguments  arguments.callee  return 自运行函数

    var ary = [1,2];
    (function fn(ary){
        //var ary;
       /* ary[0] = 0;
        ary = [];
        ary[0] = 0;
        console.log(ary);*/
    })(ary)
    console.log(ary);






</script>