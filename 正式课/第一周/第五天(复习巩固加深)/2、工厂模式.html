<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>珠峰培训</title>
</head>
<body>
<script type="text/javascript">
    //->工厂模式:把实现一个功能的代码封装到一个函数中,以后在想实现这个功能,不需要重新的编写这些代码了,只需要把函数执行一遍即可('破函数') ->低耦合高内聚:减少页面中的冗余代码地提高代码的重复利用率
    //->面向对象编程思想需要我们掌握的就是类和实例之间的这点关系，如果想把关系屡明白,需要我们研究一下有关于类的继承封装和多态
    //->函数的封装(类的封装)
    //    function sum() {
    //        var total = null;
    //        for (var i = 0; i < arguments.length; i++) {
    //            var cur = Number(arguments[i]);
    //            if (!isNaN(cur)) {
    //                total += cur;
    //            }
    //        }
    //        return total;
    //    }
    //    sum(1, 2);
    //    sum(2, 3, 4);
    //    sum(100, 200);

    //->多态:多种形态-->JS重载和JS重写
    function fn(num1, num2) {

        return;
    }

    //->后台语言中的重载:方法名相同，参数的类型或者个数不一样,这样的话我们可以把他们理解为不同的方法,以后执行的时候根据传递参数的不同,会找自己对应的方法执行 ->这一点非常能体现函数的多种形态
    //    public void sum(int num1,int num2){
    //
    //    }
    //    public void sum(int num1,int num2,int sum3){
    //
    //    }
    //    sum(1,2)
    //    sum(1,2,3)

    //->JS重载:相对于后台语言,从严格意义上来说JS中不存在重载,因为只要方法名相同,后面的就会把前面的给覆盖掉,最后只能保留一个,以后不管传什么参数,永远都执行的是最后一个
    //->非严谨的角度上来讲,JS中的重载指的是相同一个方法,我们通过传递的参数的不一样,实现不同的功能
    //    function sum(num1, num2) {
    //        console.log(1);
    //    }
    //    function sum(num1, num2, num3) {
    //        console.log(2);
    //    }
    //    sum(1, 2);
    //    sum(1, 2, 3);

    function sum(num1, num2) {
        if (typeof num2 === "undefined") {//->定义了形参没有传递任何的值
            console.log("参数错误！");
            return;
        }
        console.log(num1 + num2);
    }
    sum(1);
    sum(1, 2);
</script>
</body>
</html>